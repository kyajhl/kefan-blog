---
title: 设计模式
tags: 设计模式
categories: 学习笔记
abbrlink: 41682
date: 2023-09-03 18:23:43
---

# 模式

## 1、什么是模式？

模式就是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案

## 2、 模式的作用

高效、快速的解决应用问题

# 设计模式

## 1、设计模式包含什么

设计模式一般包含模式名称、问题、解决方案、效果等组成要素

+ 模式名称：通过一两个词来描述模式的问题、解决方案和效果、以便更好理解模式和方便开发人员交流、绝大多数模式都是根据其功能或模式结构来命名的
+ 问题：描述了应该在何时使用模式，包含了设计中存在的问题以及问题存在的原因
+ 解决方案：描述了一个设计模式的组成成分，以及这些组成成分之间的相互关系，各自的职责和协作方式，通常解决方案通过UML类图和核心代码来进行描述
+ 效果：描述了模式的优缺点以及在使用模式时应该权衡的问题

## 2、设计模式分为几种

设计模式（23种）可分为**创建型**，**结构型**和**行为型**三种

+ 创建型模式（5种）：主要用于描述如何创建对象
+ 结构型模式（7种）：主要用于描述如何实现类或对象的组合
+ 行为型模式（11种）：主要用于描述类或对象怎样交互以及怎样分配职责

> 此外，根据某个模式主要是用于处理类之间的关系还是对象之间的关系，设计模式还可以分为**类模式**和**对象模式**，我们经常将两种分类模式结合使用，如单例模式是对象创建型模式，模板方法模式是类行为模式

<h3 style="color: red">"简单工厂模式"并不在23种设计模式之中</h3>

## 3、设计模式有什么用

1. 设计模式来源众多专家的经验和智慧，它们是从许多优秀的软件系统中总结出的成功的、能够实现可维护性复用的设计方案，使用这些方案将可以让我们避免做一些重复性的工作，也许我们冥思苦想得到的一个“自以为很了不起”的设计方案其实就是某一个设计模式。在时间就是金钱的今天，设计模式无疑会为有助于我们提高开发和设计效率，但它不保证一定会提高
2. 设计模式提供了一套通用的设计词汇和一种通用的形式来方便开发人员之间沟通和交流，使得设计方案更加通俗易懂。交流通常很耗时，任何有助于提高交流效率的东西都可以为我们节省不少时间。无论你使用哪种编程语言，做什么类型的项目，甚至你处于一个国际化的开发团队，当面对同一个设计模式时，你和别人的理解并无二异，因为设计模式是跨语言、跨平台、跨应用、跨国界的
3. 大部分设计模式都兼顾了系统的可重用性和可扩展性，这使得我们可以更好地重用一些已有的设计方案、功能模块甚至一个完整的软件系统，避免我们经常做一些重复的设计、编写一些重复的代码。此外，随着软件规模的日益增大，软件寿命的日益变长，系统的可维护性和可扩展性也越来越重要，许多设计模式将有助于提高系统的灵活性和可扩展性，让我们在不修改或者少修改现有系统的基础上增加、删除或者替换功能模块。如果一点设计模式都不懂，我想要做到这一点恐怕还是很困难的
4. 合理使用设计模式并对设计模式的使用情况进行文档化，将有助于别人更快地理解系统。如果某一天因为升职或跳槽等原因，别人接手了你的项目，只要他也懂设计模式，我想他应该能够很快理解你的设计思路和实现方案，让你升职无后患之忧，跳槽也心安理得，何乐而不为呢？
5. 最后一点对初学者很重要，学习设计模式将有助于初学者更加深入地理解面向对象思想，让你知道：如何将代码分散在几个不同的类中？为什么要有“接口”？何谓针对抽象编程？何时不应该使用继承？如果不修改源代码增加新功能？同时还让你能够更好地阅读和理解现有类库（如JDK）与其他系统中的源代码，让你早点脱离面向对象编程的“菜鸟期”

> 个人观点：
>
> * 掌握设计模式并不是件很难的事情，关键在于多思考，多实践，不要听到人家说懂几个设计模式就很“牛”，只要用心学习，设计模式也就那么回事，你也可以很“牛”的，一定要有信心
> * 在学习每一个设计模式时至少应该掌握如下几点：这个设计模式的意图是什么，它要解决一个什么问题，什么时候可以使用它；它是如何解决的，掌握它的结构图，记住它的关键代码；能够想到至少两个它的应用实例，一个生活中的，一个软件中的；这个模式的优缺点是什么，在使用时要注意什么。当你能够回答上述所有问题时，恭喜你，你了解一个设计模式了，至于掌握它，那就在开发中去使用吧，用多了你自然就掌握了
> *  “如果想体验一下运用模式的感觉，那么最好的方法就是运用它们”。设计模式是“内功心法”，它还是要与“实战招式”相结合才能够相得益彰。学习设计模式的目的在于应用，如果不懂如何使用一个设计模式，而只是学过，能够说出它的用途，绘制它的结构，充其量也只能说你了解这个模式，严格一点说：不会在开发中灵活运用一个模式基本上等于没学。所以一定要做到：少说多做
> * 千万不要滥用模式，不要试图在一个系统中用上所有的模式，也许有这样的系统，但至少目前我没有碰到过。每个模式都有自己的适用场景，不能为了使用模式而使用模式？滥用模式不如不用模式，因为滥用的结果得不到“艺术品”一样的软件，很有可能是一堆垃圾代码
> * 如果将设计模式比喻成“三十六计”，那么每一个模式都是一种计策，它为解决某一类问题而诞生，不管这个设计模式的难度如何，使用频率高不高，我建议大家都应该好好学学，多学一个模式也就意味着你多了“一计”，说不定什么时候一不小心就用上了。因此，模式学习之路上要不怕困难，勇于挑战，有的模式虽然难一点，但反复琢磨，反复研读，应该还是能够征服的
> * 设计模式的“上乘”境界：“手中无模式，心中有模式”。模式使用的最高境界是你已经不知道具体某个设计模式的定义和结构了，但你会灵活自如地选择一种设计方案【其实就是某个设计模式】来解决某个问题，设计模式已经成为你开发技能的一部分，能够手到擒来，“内功”与“招式”已浑然一体，要达到这个境界并不是看完某本书或者开发一两个项目就能够实现的，它需要不断沉淀与积累，所以，对模式的学习不要急于求成

# 面向对象设计原则

## 概述

对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。在面向对象设计中，可维护性的复用是以设计原则为基础的。每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平。

面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。面向对象设计原则也是我们用于评价一个设计模式的使用效果的重要指标之一，在设计模式的学习中，大家经常会看到诸如“XXX模式符合XXX原则”、“XXX模式违反了XXX原则”这样的语句

**常见的7种面向对象设计原则**

| 设计原则名称 | 定义                                             | 使用频率 |
| ------------ | ------------------------------------------------ | -------- |
| 单一职责原则 | 一个类只负责一个功能领域中的相应职责             | ★★★★☆    |
| 开闭原则     | 软件实体应对扩展开放，而对修改关闭               | ★★★★★    |
| 里氏代换原则 | 所有引用基类对象的地方能够透明地使用其子类的对象 | ★★★★★    |
| 依赖倒转原则 | 抽象不应该依赖于细节，细节应该依赖于抽象         | ★★★★★    |
| 接口隔离原则 | 使用多个专门的接口，而不使用单一的总接口         | ★★☆☆☆    |
| 合成复用原则 | 尽量使用对象组合，而不是继承来达到复用的目的     | ★★★★☆    |
| 迪米特法则   | 一个软件实体应当尽可能少地与其他实体发生相互作用 | ★★★☆☆    |

## 1、单一职责原则

![1](设计模式/1.jpg)

如图所示的一个类，类中的方法说明如下：`getConnection()`方法用于连接数据库，`findCustomers()`用于查询所有的客户信息，`createChart()`用于创建图表，`displayChart()`用于显示图表。

`CustomerDataChart`类承担了太多的职责，既包含与数据库相关的方法，又包含与图表生成和显示相关的方法。如果在其他类中也需要连接数据库或者使用`findCustomers()`方法查询客户信息，则难以实现代码的重用。无论是修改数据库连接方式还是修改图表显示方式都需要修改该类，它不止一个引起它变化的原因，违背了单一职责原则。因此需要对该类进行拆分，使其满足单一职责原则，类`CustomerDataChart`可拆分为如下三个类：

1. `DBUtil`：负责连接数据库，包含数据库连接方法`getConnection()`
2. `CustomerDAO`：负责操作数据库中的Customer表，包含对`Customer`表的增删改查等方法，如`findCustomers()`
3. `CustomerDataChart`：负责图表的生成和显示，包含方法`createChart()`和`displayChart()`

使用单一职责原则，重构后的结构如下图所示：

![2](设计模式/2.jpg)

## 2、开闭原则

![3](设计模式/3.jpg)

如图所示，在`ChartDisplay`类的`display()`方法中存在以下片段：

```java
......
if (type.equals("pie")) {
    PieChart pieChart = new PieChart();
    pieChart.display();
} else if (type.equals("bar")) {
    BarChart barChart = new BarChart();
	barChart.display();
}
......
```

在该代码中，如果需要增加一个新的图表类，如折线图`LineChart`，则需要修改`ChartDisplay`类的`display()`方法的源代码，增加新的判断逻辑，违反了开闭原则。

现对该系统进行重构，使之符合开闭原则。

在本实例中，由于在`ChartDisplay`类的`display()`方法中针对每一个图表类编程，因此增加新的图表类不得不修改源代码。可以通过抽象化的方式对系统进行重构，使之增加新的图表类时无须修改源代码，满足开闭原则。具体做法如下：

1. 增加一个抽象图表类`AbstractChart`，将各种具体图表类作为其子类
2. `ChartDisplay`类针对抽象图表类进行编程，由客户端来决定使用哪种具体图表

重构后的结构如下图所示：

![4](设计模式/4.jpg)

我们引入了抽象图表类`AbstractChart`，且`ChartDisplay`针对抽象图表类进行编程，并通过`setChart()`方法由客户端来设置实例化的具体图表对象，在`ChartDisplay`的`display()`方法中调用`chart`对象的`display()`方法显示图表。如果需要增加一种新的图表，如折线图`LineChart`，只需要将`LineChart`也作为`AbstractChart`的子类，在客户端向`ChartDisplay`中注入一个`LineChart`对象即可，无须修改现有类库的源代码

## 3、里氏代换原则

定义：**所有引用基类（父类）的地方必须能透明地使用其子类的对象**

里氏代换原则告诉我们，**在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象**。里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此**在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象**

![5](设计模式/5.jpg)

如上图所示，客户(Customer)可以分为VIP客户(`VIPCustomer`)和普通客户(`CommonCustomer`)两类，系统需要提供一个发送Email的功能

在对系统进行进一步分析后发现，无论是普通客户还是VIP客户，发送邮件的过程都是相同的，也就是说两个`send()`方法中的代码重复，而且在本系统中还将增加新类型的客户。为了让系统具有更好的扩展性，同时减少代码重复，使用里氏代换原则对其进行重构

![6](设计模式/6.jpg)

重构之后，新增加一个`Customer`类作为`CommonCustomer`和`VIPCustomer`的抽象类，邮件发送类`EmailSender`针对抽象客户类`Customer`编程，根据里氏代换原则，能够接受基类对象的地方必然能够接受子类对象，因此将`EmailSender`中的`send()`方法的参数类型改为`Customer`，如果需要增加新类型的客户，只需将其作为`Customer`类的子类即可

## 4、依赖倒转原则

定义：***抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程***

![7](设计模式/7.jpg)

如上图所示，每次转换数据时数据来源不一定相同，因此需要更换数据转换类，如有时候需要将`TXTDataConvertor`改为`ExcelDataConvertor`，此时，需要修改`CustomerDAO`的源代码，而且在引入并使用新的数据转换类时也不得不修改`CustomerDAO`的源代码，系统扩展性较差，违反了开闭原则，现需要对该方案进行重构

重构后如下图：

![8](设计模式/8.jpg)

由于`CustomerDAO`针对具体数据转换类编程，因此在增加新的数据转换类或者更换数据转换类时都不得不修改`CustomerDAO`的源代码。我们可以通过引入抽象数据转换类解决该问题，在引入抽象数据转换类`DataConvertor`之后，`CustomerDAO`针对抽象类`DataConvertor`编程，而将具体数据转换类名存储在配置文件中，符合依赖倒转原则。根据里氏代换原则，程序运行时，具体数据转换类对象将替换`ataConvertor`类型的对象，程序不会出现任何问题。更换具体数据转换类时无须修改源代码，只需要修改配置文件；如果需要增加新的具体数据转换类，只要将新增数据转换类作为`DataConvertor`的子类并修改配置文件即可，原有代码无须做任何修改，满足开闭原则

***重点***

>在上述重构过程中，我们使用了开闭原则、里氏代换原则和依赖倒转原则，在大多数情况下，这三个设计原则会同时出现，**开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段**，它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已

## 5、接口隔离原则

定义：***使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口***

![9](设计模式/9.jpg)

如上图所示，方法`dataRead()`用于从文件中读取数据，方法`transformToXML()`用于将数据转换成XML格式，方法`createChart()`用于创建图表，方法`displayChart()`用于显示图表，方法`createReport()`用于创建文字报表，方法`displayReport()`用于显示文字报表。

在实际使用过程中发现该接口很不灵活，例如如果一个具体的数据显示类无须进行数据转换（源文件本身就是XML格式），但由于实现了该接口，将不得不实现其中声明的`transformToXML()`方法（至少需要提供一个空实现）；如果需要创建和显示图表，除了需实现与图表相关的方法外，还需要实现创建和显示文字报表的方法，否则程序编译时将报错。现使用接口隔离原则对其进行重构

重构后如下图：

![10](设计模式/10.jpg)

***在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便***

## 6、合成复用原则

